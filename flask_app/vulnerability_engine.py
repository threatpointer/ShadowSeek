"""
Vulnerability Detection Engine
Comprehensive static analysis for security vulnerabilities
"""

import re
import logging
from typing import Dict, List, Any, Tuple, Optional
from datetime import datetime
from flask import current_app

from flask_app.models import (
    Vulnerability, VulnerabilityPattern, VulnerabilityReport, 
    Function, Binary, db
)

logger = logging.getLogger(__name__)


class VulnerabilityEngine:
    """Main vulnerability detection engine"""
    
    def __init__(self):
        self.dangerous_functions = {
            # Buffer overflows & memory unsafety
            'strcpy': 'Buffer overflow risk - no bounds checking',
            'strcat': 'Buffer overflow risk - no bounds checking',
            'sprintf': 'Buffer overflow risk - no bounds checking',
            'vsprintf': 'Buffer overflow risk - no bounds checking',
            'gets': 'Buffer overflow risk - reads unlimited input',
            'scanf': 'Format string vulnerability if user input used as format',
            'sscanf': 'Format string vulnerability if user input used as format',
            'fscanf': 'Format string vulnerability if user input used as format',
            'printf': 'Format string vulnerability if user input used as format',
            'fprintf': 'Format string vulnerability if user input used as format',
            'vfprintf': 'Format string vulnerability if user input used as format',
            'snprintf': 'Potential truncation or misused bounds',
            'strncpy': 'Possible lack of null termination',
            'strncat': 'Possible buffer overflows if length misused',
            'memcpy': 'Memory corruption if size miscalculated',
            'memmove': 'Memory corruption if size miscalculated',
            'memset': 'Can overwrite critical memory if used incorrectly',
            'alloca': 'Stack overflow risk - dynamic stack allocation',

            # Command execution
            'system': 'Arbitrary command execution - dangerous with user input',
            'popen': 'Command execution - dangerous with user input',
            'execl': 'Arbitrary command execution',
            'execle': 'Arbitrary command execution',
            'execlp': 'Arbitrary command execution',
            'execv': 'Arbitrary command execution',
            'execvp': 'Arbitrary command execution',
            'execve': 'Arbitrary command execution',
            'WinExec': 'Windows API - command execution',
            'ShellExecute': 'Windows API - command execution',
            'CreateProcess': 'Windows API - launches executable, dangerous if parameters are user-controlled',

            # File system manipulation
            'tmpnam': 'Insecure temporary file name - race condition',
            'tmpfile': 'Insecure temporary file - race condition',
            'mktemp': 'Insecure temporary file name - predictable',
            'open': 'File access - use caution with user-supplied paths',
            'fopen': 'File access - path injection risk',

            # Memory mismanagement
            'malloc': 'Improper allocation can lead to overflows',
            'calloc': 'Improper allocation can lead to overflows',
            'realloc': 'Improper size can lead to heap corruption',
            'free': 'Can cause use-after-free or double-free if misused',

            # Network I/O
            'socket': 'Raw network access - validate inputs',
            'bind': 'Exposes service - make sure access is controlled',
            'listen': 'Listens for connections - ensure secure handling',
            'accept': 'Accepts external input - validate all input',
            'connect': 'External communication - validate destination',
            'recv': 'Read from network - check bounds and content',
            'send': 'Write to network - ensure data sanitization',

            # Dynamic library loading
            'LoadLibrary': 'Loads arbitrary DLLs - can be used for injection',
            'LoadLibraryEx': 'Loads arbitrary DLLs - can be used for injection',
            'GetProcAddress': 'Can be used to dynamically call dangerous APIs',
            'dlopen': 'POSIX - loads arbitrary shared libraries',

            # Misc runtime behaviors
            'abort': 'Terminates program - can be triggered by faulty logic',
            'assert': 'May crash program if condition fails',
            'raise': 'Sends signal - may cause undefined behavior',
            'vfork': 'Concurrency issue - avoid if possible',
            'clone': 'Creates new process/thread - dangerous if misused',

            # Crypto / Auth
            'getlogin': 'Authentication bypass if not validated',
            'crypt': 'Legacy password hashing - weak protection',

            # Windows-specific
            'CreateRemoteThread': 'Used in code injection attacks',
            'SetWindowsHookEx': 'Can be abused for DLL injection',
            'LogonUser': 'Handles credentials - improper use may expose secrets',
            'ImpersonateLoggedOnUser': 'Privilege escalation risk',
        }
        
        self.vulnerability_patterns = self._initialize_patterns()
    
    def _initialize_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize vulnerability detection patterns"""
        return {
            'buffer_overflow': [
                {
                    'name': 'Unbounded string copy',
                    'pattern': r'strcpy\s*\(\s*[^,]+\s*,\s*[^)]+\)',
                    'severity': 'high',
                    'cwe': 'CWE-120',
                    'description': 'strcpy() does not check buffer bounds'
                },
                {
                    'name': 'Dangerous gets() usage',
                    'pattern': r'gets\s*\(\s*[^)]+\)',
                    'severity': 'critical',
                    'cwe': 'CWE-120',  
                    'description': 'gets() reads unlimited input, always vulnerable'
                },
                {
                    'name': 'Unbounded sprintf',
                    'pattern': r'sprintf\s*\(\s*[^,]+\s*,\s*[^)]+\)',
                    'severity': 'high',
                    'cwe': 'CWE-120',
                    'description': 'sprintf() without length checking'
                }
            ],
            'format_string': [
                {
                    'name': 'User-controlled format string',
                    'pattern': r'printf\s*\(\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\)',
                    'severity': 'high',
                    'cwe': 'CWE-134',
                    'description': 'printf() with variable format string'
                },
                {
                    'name': 'fprintf with variable format',
                    'pattern': r'fprintf\s*\(\s*[^,]+\s*,\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\)',
                    'severity': 'high',
                    'cwe': 'CWE-134',
                    'description': 'fprintf() with variable format string'
                }
            ],
            'integer_overflow': [
                {
                    'name': 'Unchecked malloc size',
                    'pattern': r'malloc\s*\(\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\*\s*[a-zA-Z0-9_]+\s*\)',
                    'severity': 'medium',
                    'cwe': 'CWE-190',
                    'description': 'malloc() size calculation may overflow'
                },
                {
                    'name': 'Size multiplication without overflow check',
                    'pattern': r'[a-zA-Z_][a-zA-Z0-9_]*\s*\*\s*[a-zA-Z0-9_]+',
                    'severity': 'low',
                    'cwe': 'CWE-190',
                    'description': 'Multiplication without overflow checking'
                }
            ],
            'use_after_free': [
                {
                    'name': 'Potential use after free',
                    'pattern': r'free\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\).*\1',
                    'severity': 'high',
                    'cwe': 'CWE-416',
                    'description': 'Possible use of pointer after free()'
                }
            ],
            'command_injection': [
                {
                    'name': 'System command execution',
                    'pattern': r'system\s*\(\s*[^)]+\)',
                    'severity': 'critical',
                    'cwe': 'CWE-78',
                    'description': 'system() call may allow command injection'
                },
                {
                    'name': 'Process execution',
                    'pattern': r'exec[lv]p?\s*\(\s*[^)]+\)',
                    'severity': 'high',
                    'cwe': 'CWE-78',
                    'description': 'exec() family functions may allow command injection'
                }
            ],
            'crypto_weakness': [
                {
                    'name': 'Weak hash algorithm MD5',
                    'pattern': r'MD5|md5',
                    'severity': 'medium',
                    'cwe': 'CWE-327',
                    'description': 'MD5 is cryptographically broken'
                },
                {
                    'name': 'Weak hash algorithm SHA1',
                    'pattern': r'SHA1|sha1',
                    'severity': 'low',
                    'cwe': 'CWE-327',
                    'description': 'SHA1 is weak and deprecated'
                }
            ]
        }
    
    def scan_binary(self, binary_id: str, scan_types: List[str] = None) -> VulnerabilityReport:
        """
        Perform comprehensive vulnerability scan on binary
        
        Args:
            binary_id: Binary ID to scan
            scan_types: List of scan types to perform
            
        Returns:
            VulnerabilityReport with scan results
        """
        logger.info(f"Starting vulnerability scan for binary {binary_id}")
        
        binary = Binary.query.get(binary_id)
        if not binary:
            raise ValueError(f"Binary {binary_id} not found")
        
        if scan_types is None:
            scan_types = ['buffer_overflow', 'format_string', 'integer_overflow', 'command_injection']
        
        scan_start = datetime.utcnow()
        
        # Get functions for this binary
        functions = Function.query.filter_by(binary_id=binary_id).all()
        
        vulnerabilities = []
        functions_scanned = 0
        
        for function in functions:
            if function.decompiled_code:
                scan_result = self.scan_function(function, scan_types)
                if scan_result['success']:
                    vulnerabilities.extend(scan_result['vulnerabilities'])
                functions_scanned += 1
        
        # Store vulnerabilities in database
        for vuln_data in vulnerabilities:
            vuln = Vulnerability(
                binary_id=binary_id,
                function_id=vuln_data.get('function_id'),
                vulnerability_type=vuln_data['type'],
                severity=vuln_data['severity'],
                title=vuln_data['title'],
                description=vuln_data['description'],
                address=vuln_data.get('address'),
                cwe_id=vuln_data.get('cwe_id'),
                risk_score=vuln_data['risk_score'],
                affected_code=vuln_data.get('code_snippet'),
                remediation=vuln_data.get('remediation'),
                detection_method='static_analysis',
                confidence=vuln_data.get('confidence', 75)
            )
            db.session.add(vuln)
        
        # Create summary statistics
        severity_counts = self._calculate_severity_counts(vulnerabilities)
        overall_risk_score = self._calculate_overall_risk(vulnerabilities)
        
        # Create vulnerability report
        report = VulnerabilityReport(
            binary_id=binary_id,
            scan_types=scan_types,
            total_vulnerabilities=len(vulnerabilities),
            critical_count=severity_counts['critical'],
            high_count=severity_counts['high'],
            medium_count=severity_counts['medium'],
            low_count=severity_counts['low'],
            info_count=severity_counts['info'],
            overall_risk_score=overall_risk_score,
            risk_category=self._get_risk_category(overall_risk_score),
            scan_duration=int((datetime.utcnow() - scan_start).total_seconds()),
            functions_scanned=functions_scanned,
            patterns_applied=len([p for patterns in self.vulnerability_patterns.values() for p in patterns]),
            completed_at=datetime.utcnow()
        )
        
        db.session.add(report)
        db.session.commit()
        
        logger.info(f"Vulnerability scan completed for binary {binary_id}: {len(vulnerabilities)} vulnerabilities found")
        
        return report
    
    def scan_function(self, function: Function, scan_types: List[str]) -> Dict[str, Any]:
        """
        Scan individual function for vulnerabilities (Unified Security Analysis Compatible)
        
        Args:
            function: Function object to scan
            scan_types: Types of vulnerabilities to scan for
            
        Returns:
            Dictionary with scan results compatible with unified security analysis
        """
        if not function.decompiled_code:
            return {
                'success': False,
                'error': 'Function has no decompiled code',
                'vulnerabilities': [],
                'patterns_matched': [],
                'metadata': {}
            }
        
        try:
            vulnerabilities = []
            patterns_matched = []
            code = function.decompiled_code
            
            # Check dangerous function usage
            dangerous_func_vulns = self._check_dangerous_functions(function, code)
            vulnerabilities.extend(dangerous_func_vulns)
            
            # Apply pattern-based detection
            for scan_type in scan_types:
                if scan_type in self.vulnerability_patterns:
                    pattern_vulns = self._apply_patterns(function, code, scan_type)
                    vulnerabilities.extend(pattern_vulns)
                    patterns_matched.extend([
                        {'type': scan_type, 'count': len(pattern_vulns)}
                        for _ in range(len(pattern_vulns))
                    ])
            
            # Advanced analysis
            advanced_vulns = self._advanced_analysis(function, code)
            vulnerabilities.extend(advanced_vulns)
            
            return {
                'success': True,
                'vulnerabilities': vulnerabilities,
                'patterns_matched': patterns_matched,
                'metadata': {
                    'function_id': function.id,
                    'function_name': function.name or function.address,
                    'scan_types': scan_types,
                    'total_vulnerabilities': len(vulnerabilities),
                    'dangerous_functions_found': len(dangerous_func_vulns),
                    'pattern_matches': len(patterns_matched),
                    'advanced_findings': len(advanced_vulns)
                }
            }
            
        except Exception as e:
            logger.error(f"Error scanning function {function.address}: {e}")
            return {
                'success': False,
                'error': str(e),
                'vulnerabilities': [],
                'patterns_matched': [],
                'metadata': {}
            }
    
    def scan_function_legacy(self, function: Function, scan_types: List[str]) -> List[Dict[str, Any]]:
        """
        Legacy scan individual function for vulnerabilities (returns list)
        
        Args:
            function: Function object to scan
            scan_types: Types of vulnerabilities to scan for
            
        Returns:
            List of vulnerability dictionaries
        """
        result = self.scan_function(function, scan_types)
        return result.get('vulnerabilities', [])
    
    def _check_dangerous_functions(self, function: Function, code: str) -> List[Dict[str, Any]]:
        """Check for usage of dangerous functions"""
        vulnerabilities = []
        
        for func_name, description in self.dangerous_functions.items():
            if func_name in code:
                severity = self._get_function_severity(func_name)
                risk_score = self._get_function_risk_score(func_name, severity)
                
                vuln = {
                    'function_id': function.id,
                    'type': 'dangerous_function',
                    'severity': severity,
                    'title': f'Usage of dangerous function: {func_name}',
                    'description': description,
                    'address': function.address,
                    'risk_score': risk_score,
                    'code_snippet': self._extract_code_snippet(code, func_name),
                    'remediation': self._get_function_remediation(func_name),
                    'confidence': 85
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _apply_patterns(self, function: Function, code: str, scan_type: str) -> List[Dict[str, Any]]:
        """Apply regex patterns for vulnerability detection"""
        vulnerabilities = []
        patterns = self.vulnerability_patterns.get(scan_type, [])
        
        for pattern_def in patterns:
            matches = re.finditer(pattern_def['pattern'], code, re.IGNORECASE)
            for match in matches:
                vuln = {
                    'function_id': function.id,
                    'type': scan_type,
                    'severity': pattern_def['severity'],
                    'title': pattern_def['name'],
                    'description': pattern_def['description'],
                    'address': function.address,
                    'cwe_id': pattern_def.get('cwe'),
                    'risk_score': self._severity_to_risk_score(pattern_def['severity']),
                    'code_snippet': match.group(0),
                    'confidence': 70
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _advanced_analysis(self, function: Function, code: str) -> List[Dict[str, Any]]:
        """Perform advanced vulnerability analysis"""
        vulnerabilities = []
        
        # Check for memory allocation patterns
        malloc_count = len(re.findall(r'\bmalloc\s*\(', code))
        free_count = len(re.findall(r'\bfree\s*\(', code))
        
        if malloc_count > free_count and malloc_count > 0:
            vuln = {
                'function_id': function.id,
                'type': 'memory_leak',
                'severity': 'medium',
                'title': 'Potential memory leak',
                'description': f'Function has {malloc_count} malloc calls but only {free_count} free calls',
                'address': function.address,
                'cwe_id': 'CWE-401',
                'risk_score': 40,
                'confidence': 60
            }
            vulnerabilities.append(vuln)
        
        # Check for array access patterns
        array_patterns = re.findall(r'\w+\[\s*\w+\s*\]', code)
        if array_patterns and 'bounds' not in code.lower():
            vuln = {
                'function_id': function.id,
                'type': 'buffer_overflow',
                'severity': 'medium',
                'title': 'Potential buffer overflow in array access',
                'description': 'Array access without visible bounds checking',
                'address': function.address,
                'cwe_id': 'CWE-120',
                'risk_score': 50,
                'confidence': 40
            }
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _get_function_severity(self, func_name: str) -> str:
        """Get severity level for dangerous function"""
        critical_funcs = ['gets', 'system']
        high_funcs = ['strcpy', 'strcat', 'sprintf', 'execl', 'execv', 'CreateProcess']
        
        if func_name in critical_funcs:
            return 'critical'
        elif func_name in high_funcs:
            return 'high'
        elif func_name in ['malloc', 'free', 'printf', 'fprintf']:
            return 'medium'
        else:
            return 'low'
    
    def _get_function_risk_score(self, func_name: str, severity: str) -> int:
        """Calculate risk score for function usage"""
        base_scores = {'critical': 90, 'high': 75, 'medium': 50, 'low': 25}
        return base_scores.get(severity, 25)
    
    def _severity_to_risk_score(self, severity: str) -> int:
        """Convert severity to risk score"""
        scores = {'critical': 90, 'high': 75, 'medium': 50, 'low': 25, 'info': 10}
        return scores.get(severity, 25)
    
    def _extract_code_snippet(self, code: str, func_name: str) -> str:
        """Extract code snippet around function usage"""
        lines = code.split('\n')
        for i, line in enumerate(lines):
            if func_name in line:
                start = max(0, i - 2)
                end = min(len(lines), i + 3)
                return '\n'.join(lines[start:end])
        return func_name
    
    def _get_function_remediation(self, func_name: str) -> str:
        """Get remediation advice for dangerous function"""
        remediations = {
            'strcpy': 'Use strncpy() or strlcpy() with proper bounds checking',
            'strcat': 'Use strncat() or strlcat() with proper bounds checking', 
            'sprintf': 'Use snprintf() with buffer size limits',
            'gets': 'Use fgets() with buffer size limits',
            'system': 'Avoid system() calls, use execv() family with sanitized inputs',
            'malloc': 'Check return value and pair with free(), consider using smart pointers',
            'printf': 'Use format string literals, never pass user input as format string'
        }
        return remediations.get(func_name, 'Review usage and implement proper input validation')
    
    def _calculate_severity_counts(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
        """Calculate vulnerability counts by severity"""
        counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'low')
            counts[severity] = counts.get(severity, 0) + 1
        return counts
    
    def _calculate_overall_risk(self, vulnerabilities: List[Dict[str, Any]]) -> int:
        """Calculate overall risk score"""
        if not vulnerabilities:
            return 0
        
        total_score = sum(vuln.get('risk_score', 0) for vuln in vulnerabilities)
        avg_score = total_score / len(vulnerabilities)
        
        # Boost score for high-severity issues
        critical_count = sum(1 for v in vulnerabilities if v.get('severity') == 'critical')
        high_count = sum(1 for v in vulnerabilities if v.get('severity') == 'high')
        
        boost = (critical_count * 15) + (high_count * 10)
        final_score = min(100, int(avg_score + boost))
        
        return final_score
    
    def _get_risk_category(self, risk_score: int) -> str:
        """Convert risk score to category"""
        if risk_score >= 80:
            return 'critical'
        elif risk_score >= 60:
            return 'high'
        elif risk_score >= 40:
            return 'medium'
        else:
            return 'low'
    
    def get_vulnerability_summary(self, binary_id: str) -> Dict[str, Any]:
        """Get vulnerability summary for binary"""
        report = VulnerabilityReport.query.filter_by(binary_id=binary_id).order_by(
            VulnerabilityReport.created_at.desc()
        ).first()
        
        if not report:
            return {'total': 0, 'risk_score': 0, 'vulnerabilities': []}
        
        vulnerabilities = Vulnerability.query.filter_by(binary_id=binary_id).all()
        
        return {
            'report_id': report.id,
            'total': report.total_vulnerabilities,
            'summary': report.to_dict()['summary'],
            'risk_score': report.overall_risk_score,
            'risk_category': report.risk_category,
            'vulnerabilities': [v.to_dict() for v in vulnerabilities[:20]]  # Limit for performance
        } 